---
title: "Distribution Transaction"
description: 
slug: Distribution Transaction
date: 2025-02-10T22:34:00+08:00
image: cover.png
categories:
    - Transaction
tags:
    - Transaction
weight: 1       # You can add weight to some posts to override the default sorting (date descending)
---

## 分布式事务基本概念

### 分布式系统架构演进

#### 单体应用架构

![](single_application.png)

在单体应用架构下所有功能都被打包成一个服务并部署，这种架构具有如下优点：

   - 架构简单、项目开发和维护成本低
   - 所有项目部署在一起，方便维护。

但单体应用架构也存在诸多缺陷：

   - 所有模块耦合在一起，不容易开发和维护（合并分支需要解决冲突，大项目启动事件长）
   - 项目模块过于耦合，一个模块出问题可能导致整个项目不可用
   - 无法针对某个具体模块提升性能（所有的模块都部署在一起，无法针对单个模块进行水平扩展）
   - 无法对项目进行水平扩展（项目大启动时间长，项目部署低效）

#### 垂直应用架构

![](vertical.png)

垂直应用架构将系统按照业务领域进行拆分，当有业务领域流量增大只需要针对单个业务领域增加节点，无需对整个项目增加服务器节点。该架构具有如下优点：
    
  - 可以针对不同系统进行优化
  -   能够实现水平扩展
  -   各系统能够分担流量，减小并发度
  -   系统与系统隔离，单系统出现故障不影响其他系统运行

垂直应用架构仍然存在如下缺点：

  - 拆分后的系统之间相互独立，无法进行相互调用
  - 拆分粒度大，重复代码片段多，会出现重复开发与难以维护的问题

#### 分布式架构

![](distribution.png)

分布式架构在垂直架构的基础上，将重复的代码抽出来独立未单独的服务。整个系统被拆分为服务层和表现层，表现层负责处理与页面的交互，服务层则封装了具体的业务逻辑供表现层调用。这种架构具有如下优点：

  - 提高了代码的服用程度，降低了维护成本。
  - 可以针对服务进行性能优化。
  
但该架构具有如下缺点：

  - 系统之间的调用关系变得复杂
  - 系统之间的依赖关系变得复杂
  - 系统维护成本变高
  
##### SOA架构

![](soa.png)

SOA架构引入了注册中心解决了服务依赖与调用关系的自动注册与发现。但这种架构有如下缺点：

  - 各服务间存在依赖关系，如果某个服务出现故障可能会造成服务器崩溃。
  - 服务间的依赖与调用关系复杂增加了测试和运维成本。

#### 微服务架构

微服务架构与SOA架构相比有如下差异：

![](micro_service.png)

  - 服务大小：在SOA架构中，服务通常是大型的负责多个业务功能；微服务架构中服务负责的功能更具体，通常是某个业务的具体功能。
  - 数据存储：在SOA架构个中服务共用同一个数据库；微服务每个服务通常拥有自己的数据库。
  - 通信协议：SOA通常采用SOAP等复杂的通信协议；微服务通常采用REST或gRPC。
  - 服务协调：SOA通常采用中心话的协调方式如ES；微服务通常采用去中心化的服务方式，如API网关。
  - 部署方式：SOA通常集中部署；微服务一般进行单独部署。

在SOA架构中，服务通常是大型的负责多个业务功能，不同服务共用一个数据库，

### 分布式事务场景

一个事务需要多个服务远程协作完成就会产生分布式事务问题，分布式事务会在三种场景下产生，分别是跨JVM进程、跨数据库实例、和多服务访问单数据库。

#### 跨JVM进程（多服务、多数据库）
![]( multi_service_multi_database.png)
#### 跨数据库实例（单服务、多数据库）
![](single_service_multi_database.png)
#### 和多服务访问单数据库（多服务、单数据库）
![](multi_service_single_database.png)

### 数据一致性

数据一致性问题包含多副本、调用超时、缓存与数据库不一致、多个缓存节点数据不一致等场景。

#### 调用超时场景

调用超时指的是A服务同步或者异步调用B服务超时，导致A服务与B服务数据不一致。

#### 缓存与数据库不一致

在高并发场景下，一些热点数据会缓存到Redis等组件中，此时如果对数据库中的数据进行写操作将会导致缓存中的数据与数据库中的数据不一致。

#### 多缓存节点数据不一致

缓存内部各节点数据不一致，如在Redis集群中，由于网络问题导致多个缓存节点数据不一致。


## 分布式事务理论知识
### CAP（Consistency、Availability、Partition Tolerance）理论
CAP理论：在分布式系统，不会同时具备CAP三个特性，只能同时具备其中两个。

1. 一致性
   
    用户对数据的写操作在所有数据副本要么都成功、要么都失败。

2. 可用性
    
    客户端访问数据时能够快速得到响应。

3. 分区容忍性
   
   分区：分布式系统中不同节点间通信出现了问题。分区容忍：在出现分区时系统仍然能对外提供服务。
   
### 为什么CAP只能满足其中两个

首先需要明确的是一个分布式系统必需要满足分区容错，也就是CAP中的P。在分布式系统中分区是一定会出现的，没有人能够保证节点与节点之间的网络总是不出问题，也没有人能够保证单个节点始终运行正常。如果一个分布式系统出现分区整个系统就停止服务，那其与单体服务并无区别（分布式系统的初衷就是通过多节点部署来提高系统的可用性）。

在出现分区的情况下，一致性与可用性只能满足其一：

1. 若要满足一致性，在对数据的多副本进行写入时需要锁定资源，而出现分区导致无法确认所有副本都写入成功，客户端的访问也无法在有效时间内得到响应。
   
2. 若要满足可可用性，对任意节点的访问都需要在指定时间得到响应，当被访问节点数据写入成功而存在节点数据未写入成功或者被访问节点数据未写入成功而其余节点数据写入成功则可用性也无法得到满足。

### BASE（Basically Available, Soft State， Eventually Consistent）理论

当出现分区时，BASE理论允许部分数据不可用，但会保证核心功能可用；允许数据在一定时间内不一致，但经过一段时间数据最终是一致的。

1. 基本可用
    
    基本可用指的是分布式系统出现故障时，允许损失部分可用性（比如响应时间或部分功能）

2. 软状态
    
    软状态指的是允许系统出现中间状态，但中中间状态不会影响系统的整体可用性。

3. 最终一致性

    最终一致性指的是允许允许数据在各个节点存在不一致，只需要数据最终一致。



## 分布式事务解决方案

### 强一致性分布式事务解决方案

强一致性事务要求任意时刻参与全局事务的各个节点的数据都一致。

### 强一致性事务的三种方案

#### 全局事务模型（DTP）

1. 基本概念
   1. 事务：一个完整的工作单元，具备ACID特性
   2. 全局事务：事务管理器管理的全局事务，能一次操作多个资源管理器
   3. 分支事务：全局事务中的每个资源管理器中独立执行的事务
   4. 控制线程：执行全局事务的线程
   
2. 执行流程
    ![](DTP.png)
    DTP模型中的三个核心组件：
    - AP（应用程序、Application Program）：参与DTP分布式事务模型的应用程序。
    - RM（资源管理器、Resource Manager）：数据库管理系统或者消息服务管理器，用来对响应的资源进行有效的控制，相应的资源需要实现XA定义的接口。
    - TM（事务管理器、Transaction Manager）：负责协调和管理DTP模型中的事务，为应用程序提供编程接口，同时管理资源管理器。

#### 二阶段提交模型（2PC）

2PC模型即两阶段提交协议模型，该模型将事务流程分为Prepare阶段和Commit阶段。

1. Prepare阶段
   
    ![](2PC_step_one.png)

    在Prepare阶段，事务管理器给每个参与全局事务的资源管理器发送Prepare消息，资源管理器要么返回失败，要么在本地执行相应的事务，将事务写入本地的Redo Log文件和Undo Log文件，但此时事务并未提交。

    如果在Prepare阶段有资源管理器返回了失败消息则在Commit阶段事务管理器会向其他响应正常消息发送回滚消息。

2.  Commit阶段
   
   ![](2PC_step_two.png)

   在2PC的commit阶段，事务管理器向参与全局事务的资源管理器发送commit消息，资源管理器收到消息后提交本地事务并将提交成功的消息返回给事务管理器。



#### 三阶段提交模型（3PC）

相比与2PC模型，3PC模型将prepare阶段分成了CanCommit阶段与PreCommit阶段。

1. CanCommit阶段

在CanCommit阶段，事务管理器会向资源管理器发送CanCommit消息，资源管理器如果认为可以执行任务则发送确认消息并进入预备状态。

![](can_commit.png)

2. PreCommit阶段

在PreCommit阶段，资源管理器接受到消息并写入undo log与redo log。

![](prepare_commit.png)

3. DoCommit阶段

![](do_commit.png)

在DoCommit阶段，资源管理器收到消息并提交事务。如果超过一定时间资源管理器没有收到事务管理器发送的事务回滚消息则会直接提交事务，如果其资源管理器收到了回滚消息则会导致数据不一致。

### 最终一致性的三种解决方案

强一致性方案要求参与事务的各个节点的数据时刻保持一致，在高并发场景下会影响性能。最新一致性方案不要求各个节点的数据始终保持一致，只要数据最终一致即可。

#### 服务模式

##### 可查询操作

![](can_search.png)

可查询操作服务模型要求操作具有唯一标识（唯一业务标识及操作时间）并且要求其他服务在提供操作接口的情况下提供查询接口及批量查询接口，在分布式环境下可以通过查询接口确认操作是否我那次。

##### 幂等操作

![](mideng.png)

幂等操作要求对于同一个方法相同的参数，操作一次和操作多次的结果相同。在分布式环境下，常常需要重试，而幂等可保证重试对最终结果没有影响。

##### TCC操作

![](TCC.png)

TCC模式包含Try，Commit，Cancel三个阶段。在try阶段完成所有业务的一致性检查、预留必要的业务资源，并需要与其他操作隔离。在Commit执行真正的业务操作。在Cancel释放预留的资源。

##### 可补偿操作

![](buchang.png)

在分布式环境下数据可能出现不一致，这时需要通过补偿接口进行补偿。
在分布式环境下数据可能出现不一致，这时需要通过补偿接口进行补偿。


#### TCC 方案

![](TCC_solver.png)

1. Try阶段

在 Try 阶段在具体的业务数据进行修改操作并标记状态为待提交，并记录此阶段的反向操作（如增加多少库存）

2. Confirm阶段

如果 Try 阶段执行全部成功，则将待提交状态标记为提交状态并取消反向操作。

3. Cancel阶段

标记操作的具体业务数据状态为取消，并对业务数据进行反向操作，清除具体的反向操作。


#### 可靠消息最终一致性解决方案

![](reliable_message.png)

事务发起方发送可靠消息，事务参与方从可靠消息服务接收消息。由于事务发起方和可靠消息服务、可靠消息服务和事务参与方之间都是通过网络进行通信的，所以需要引入消息确认服务和消息回复服务。


消息确认服务会定期检测事务发起方业务的执行状态和消息库中的数据，如果发现事务发起方业务的执行状态与消息库中的数据不一致，消息确认服务就会同步事务发起方的业务数据和消息库中的数据，保证数据一致性。

消息恢复服务会定期检测事务参与方业务执行状态与消息库中数据是否一致，如果发现不一致则回滚消息状态为事务发起方发送消息但未被事务参与方消费的状态。


#### 最大努力通知型解决方案

![](try_best.png)

业务方在完成业务处理后，会向业务参与方发送消息，发送消息时通知时运行消息丢失。业务方需要体统查询接口供业务接收方按需查询，用于恢复丢失的消息。


## 分布式事务原理

### 可靠消息分布式事务

#### 可靠消息需要解决的核心问题

  ![工作方式](basic_schematic_diagram.png)

  可靠消息分布式事务一共包含了四步操作：

   - 事务发起方执行事务
   - 事务发起方投递消息
   - 事务参与方消费消息
   - 事务参与方处理消息
  
  上面的四步操作要么全做要么全不做，可能出现四中场景：
   - 事务发起方执行事务失败
   - 事务发起方投递消息失败
   - 事务参与方消息消费失败
   - 事务参与方处理消息失败
  
  当出现上面四中场景中的任意一种之后，需要保证
   - 事务发起方一定能回滚至事务提交前的状态
   - 事务参与方一定能回滚至消息处理前的状态
  
  在可靠消息分布式事务中一共包含了三个角色：事务发起方、消息中间件、事务参与方，各个角色实现如下任务：
  
  - 事务参与方：消息提交成功和执行事务成功要么全做要么全不做
  - 消息中间件：能够正确返回消息提交及消息消费的状态给事务参与方
  - 消息消费者：处理消息失败能正确返回消息执行状态

#### 各个角色实现任务的难点

  - 事务参与方如何保证事务提交与消息投递是原子操作

     - 先发消息
        - 执行事务前发消息：消息发送成功但事务执行失败，只回滚了事务并没有实现消息发送和写库都执行失败或者都执行成功。如果消息接收方通过接口回调来确认消息状态，在读已提交和可重复读的隔离级别下设置回调时间过短可能导致没有正确获取到事务的执行状态。
        - 执行事务时发送消息：在写库完成前发送消息可能会出现消息发送成功，但写库失败的场景。在网络波动是，发送消息等待响应时间长，会阻塞事务执行，影响系统安全。

     - 先写库
       - 执行事务后发送消息：在提交事务后设置回调发送消息，单事务已提交，消息可能发送失败。
       - 事务执行时发送消息：在写库完成后发送消息，发送消息失败则回滚。在网络波动时，发送消息等待响应时间长，会阻塞事务执行，影响系统安全。

    上面的两种方式还可按照 在事务内发消息还是在事务外发消息划分，二者各有如下缺点

    - 在事务内发消息

      在事务内发消息，在网络超时，生产者重试，可能阻塞事务导致死锁等问题。
    
    - 在事务外发消息
  
      难以保证事务执行成功消息提交成功是原子操作。
        
  - 消息中间件平台如何保证返回给事务发起方消息投递及消息消费的正确状态

    - 如何返回消息投递正确状态
      - 如何确保返回给事务发起方的投递失败的状态真实可靠
        在网络超时时，事务参与方任务消息发送失败，但消息可能投递成功，导致事务参与方与事务发起方状态不一致。
      - 如何确保返回给事务发起方投递成功的状态真实可靠
        在消息中间件宕机这种极端情况下，如何保证消息能够正确投递
    - 如何返回消息消费正确状态
        在网络波动时，消费者没有在指定时间返回消息处理状态，消息中间件错误地返回回滚消息给事务发起方，导致事务发起方回滚消息，导致事务参与方与事务发起方状态不一致。

  在事务内发送消息会影响数据安全是必须要避免的，现在需要解决的问题是如何在事务外发送消息的情况下保证： 发送消息成功、提交事务、投递消息成功、消费消息成功要么全做要么全不做。

  #### 本地消息表

  - 工作过程

    - 事务发起方提交事务

      事务发起方在写业务数据时向本地消息表也写一份数据用于记录需要发送消息，并且将两个写操作放在一个事务中保证业务数据写操作与本地消息表的记录要么全做要么全不做。
    
    - 事务发起方发送消息

      使用定时任务不断扫描本地消息表，发送消息至消息中间件，如果消息没有发送成功则会不断重试，在重试一定次数仍然失败之后则会把消息放入实信对列，之后进行人工干预。
    
    - 事务参与方接收消息并消费

![alt text](local_message_table.png)

   - 各角设如何保证完成自己的任务

     - 事务发起方如何保证提交事务和发送消息是一个原子操作

        本地消息表将写业务数据与写本地消息表放在一个事务里，保证这两个操作能同时执行，此外通过不断重试消息并引入人工处理来保证消息一定能够发送并被消费者消费。

     - 消息中间件如何保证成功返回消息消费状态

        事务参与方提交事务失败时发送一个消息给事务发起方通知其回滚消息。

  - 优点

     - 本地消息表是业界内比较成熟的方案，可靠性高。
     - 本地消息表实现了数据的最终一致性。

  - 缺点

    - 可靠消息保证与业务代码耦合，需要额外开发定时任务等逻辑。
    - 可靠消息保证的相关逻辑无法复用，需要重复开发。

   - 注意点

     - 事务提交后需要保证消息一定投递成功，可能会频繁重试，事务参与方需要保证消息的幂等。
     - 事务参与方通过消息投递通知事务发起方回滚，如果事务参与方也需要保证消息可靠投递。

  #### 独立消息服务

  独立消息服务将本地消息表中可靠消息保证的逻辑抽离成独立服务并进行了增强，其工作步骤如下：

  - 事务发起方发送消息至可靠消息服务，发送成功后执行本地事务。
  - 可靠消息服务接收到消息后存储到消息库中并将消息状态标记为“待发送”但不会立即发送消息至消息中间件。
  - 事务执行成功或失败后事务发起方向可靠消息服务发送确认消息。
  - 可靠消息服务接收到事务发起方投递消息，若收到确认消息则将消息发送至中间件并将消息状态标记为已发送；若收到取消消息则将消息库中保存的消息标记为已删除。
  - 消息中间件投递消息至事务参与方，事务参与方接收消息并将处理结果返回给消息中间件。
  - 消息中间件将消费结果投递至可靠消息服务，可靠消息服务接收到确认消息将消息状态标记为已完成。

![可靠消息](reliable_message.png)

  - 各个角色如何保证完成自己的任务

    - 事务发起方如何保证提交事务和发送消息是一个原子操作

      - 执行事务前发送消息失败：发送消息失败事务发起方不会提交事务，如果因网络超时事务发起方发送事务成功但没有收到正确响应，可靠消息服务没有接收到确认消息也不会向事务产生方投递消息。
      - 执行事务成功如何确保发送确认消息成功：执行事务成功，消息发送失败事务发起方与事务参与方状态不一致，消息确认服务会不断校对事务发起方和消息库中消息的状态，发现不一致时会进行校对。
    - 消息中间件如何确保正确返回消息投递及消费状态给事务发起方：
  
      - 正确返回消息投递至可靠消息服务的状态：消息确认服务会不断地对事务发起方事务的执行状态和消息库中消息的状态进行校准。
      - 正确返回消息投递至消息中间件的状态：可靠消息服务会重试消息投递，重试失败后会由消息恢复服务定时重试。

   - 一点讨论
     - 独立消息服务中引入了可靠消息服务，整个消息投递链路又多了一个节点，会引入更多的中间状态，独立消息服务内含一个建设经过一定次数的投递消息一定能投递成功。
     - 独立消息服务并没有对返回正确消费状态给事务发起方作保证，但同样基于一定次数的投递消息一定能投递成功这个假设，经过一定次数的投递独立消息也能正确返回状态给事务发起方。

#### RocketMQ事务消息

 RocketMQ工提供了事务消息，工作过程与独立消息服务基本一致，下面我们通过代码来学习RocketMQ事务消息。

![Rocket MQ](rocketMQ.png)

假设我们有一个商场业务下单扣减库存的场景，订单微服务和库存微服务分别部署，订单微服务在生成订单后需要通知库存微服务扣减库存。

![alt text](image.png)

总共涉及到三张表，order表用来存储订单数据，stock表用来存储库存数据，tx_log表用来记录事务。
![order表](order.png)